/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useEffect } from 'react';
import {
  useGLTF,
  useTexture,
  shaderMaterial,
  Points,
  Point,
} from '@react-three/drei';
import { extend, useFrame } from '@react-three/fiber';
import model from '../../../models/hero_model.glb';
import baked from '../../../img/bakes/heroBake.jpg';
import {
  BufferAttribute,
  sRGBEncoding,
  Vector2,
  FloatType,
  AdditiveBlending,
  NormalBlending,
} from 'three';
import { gsap, Power1 } from 'gsap';
import pointsVertexShader from '../../../shaders/points/vertex.glsl';
import pointsFragmentShader from '../../../shaders/points/fragment.glsl';
import portalVertexShader from '../../../shaders/portal/vertex.glsl';
import portalFragmentShader from '../../../shaders/portal/fragment.glsl';
import { EffectComposer, SelectiveBloom } from '@react-three/postprocessing';
import { Resizer, KernelSize } from 'postprocessing';
import useStore from '../../../store';

const PointsMaterial = shaderMaterial(
  {
    uTime: 0,
    uMouse: new Vector2(0, 0),
  },
  pointsVertexShader,
  pointsFragmentShader,
  (shaderMaterial) => {
    shaderMaterial.vertexColors = true;
    shaderMaterial.transparent = true;
    shaderMaterial.depthWrite = false;
    shaderMaterial.blending = NormalBlending;
  }
);

const PortalMaterial = shaderMaterial(
  {
    uTime: 0,
    uMouse: new Vector2(0, 0),
  },
  portalVertexShader,
  portalFragmentShader
);

extend({ PointsMaterial, PortalMaterial });

export default function Model(props) {
  const group = useRef();
  const letters = useRef();
  const airRock1 = useRef();
  const airRock2 = useRef();
  const airRock3 = useRef();
  const airRock4 = useRef();
  const pointsRef = useRef();
  const emissionRef = useRef();
  const platformRef = useRef();

  const bakedTex = useTexture(baked);

  bakedTex.flipY = false;
  bakedTex.encoding = sRGBEncoding;

  const pointCount = 200;
  const points = [];
  const aOffset = new Float32Array(pointCount);

  for (let i = 0; i < pointCount; i++) {
    let x = Math.random() * 2 - 1;
    let y = Math.random() * 2 - 1;
    let z = Math.random() * 2 - 1;

    let offset = Math.random();
    aOffset[i] = offset;

    let color = Math.random() > 0.5 ? '#ff9e9e' : '#c0def2';

    points.push(
      <Point
        key={i}
        offset={Math.random()}
        color={color}
        position={[x, y, z]}
      />
    );
  }

  useEffect(() => {
    gsap.to(letters.current.position, {
      duration: 3,
      ease: Power1.easeInOut,
      y: 7.5,
      repeat: -1,
      yoyo: true,
    });

    gsap.to(airRock1.current.position, {
      duration: 2.8,
      ease: Power1.easeInOut,
      y: 3,
      repeat: -1,
      yoyo: true,
    });

    gsap.to(airRock2.current.position, {
      duration: 3.2,
      ease: Power1.easeInOut,
      y: 12.5,
      repeat: -1,
      yoyo: true,
    });

    gsap.to(airRock3.current.position, {
      duration: 2.4,
      ease: Power1.easeInOut,
      y: 9,
      repeat: -1,
      yoyo: true,
    });

    gsap.to(airRock4.current.position, {
      duration: 3.25,
      ease: Power1.easeInOut,
      y: 4.3,
      repeat: -1,
      yoyo: true,
    });
  }, []);

  useEffect(() => {
    pointsRef.current.geometry.setAttribute(
      'aOffset',
      new BufferAttribute(aOffset, 1)
    );
  }, [aOffset]);

  useFrame(({ clock }) => {
    pointsRef.current.material.uniforms.uTime.value = clock.elapsedTime;
  });

  const { nodes } = useGLTF(model);

  return (
    <>
      <group ref={group} {...props} dispose={null}>
        <mesh
          geometry={nodes.letters.geometry}
          ref={letters}
          position={[0.05574, 6.93339, -0.00698]}
        >
          <meshBasicMaterial map={bakedTex} />
        </mesh>
        <mesh
          geometry={nodes.air_rock001.geometry}
          ref={airRock1}
          position={[-3.14247, 1.59546, 3.03652]}
        >
          <meshBasicMaterial map={bakedTex} />
        </mesh>
        <mesh
          geometry={nodes.air_rock002.geometry}
          ref={airRock2}
          position={[-2.40939, 11.24023, -2.64953]}
        >
          <meshBasicMaterial map={bakedTex} />
        </mesh>
        <mesh
          geometry={nodes.air_rock003.geometry}
          ref={airRock3}
          position={[4.34263, 7.24577, -2.62799]}
        >
          <meshBasicMaterial map={bakedTex} />
        </mesh>
        <mesh
          geometry={nodes.air_rock.geometry}
          ref={airRock4}
          position={[3.15335, 3.2013, 2.33815]}
        >
          <meshBasicMaterial map={bakedTex} />
        </mesh>
        <mesh
          ref={platformRef}
          geometry={nodes.platform.geometry}
          position={[-0.03233, -1.16806, -1.12225]}
        >
          <meshBasicMaterial map={bakedTex} />
        </mesh>
        <mesh
          ref={emissionRef}
          geometry={nodes.emissive.geometry}
          position={[-0.20013, -0.70351, 0.21569]}
          scale={[1.1, 1, 1.1]}
        >
          <portalMaterial />
        </mesh>
        <Points
          ref={pointsRef}
          position={[-0.20013, -0.70351, 0.21569]}
          scale={[1, 1, 1]}
          range={pointCount}
        >
          {points}

          <pointsMaterial />
        </Points>
      </group>

      <EffectComposer frameBufferType={FloatType} multisampling={8}>
        <SelectiveBloom
          lights={[emissionRef]}
          selection={[platformRef]}
          width={Resizer.AUTO_SIZE}
          height={Resizer.AUTO_SIZE}
          kernelSize={KernelSize.LARGE}
          intensity={1.3}
          luminanceThreshold={0.6}
          luminanceSmoothing={0.2}
        />
      </EffectComposer>
    </>
  );
}

useGLTF.preload(model);
